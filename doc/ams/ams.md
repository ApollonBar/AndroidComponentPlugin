
而在内部可以看到先从ServiceManager中获取到AMS远端服务的Binder对象，然后使用asInterface方法转化成本地化对象，
其实就是ActivityManagerProxy对象。
然后我们在看看上面调用了startActivityAsUser方法，其实就是调用了ActivityManagerProxy对象的这个方法：



在这个过程中，我们在上一篇分析系统中的剪切板服务的时候，这里分析就不难了，主要有四个对象：

1、IActivityManager：这个是远端服务AIDL协议接口类型，定义了很多方法

2、ActivityManagerProxy：这个是本地端中间者对象，也就是我们应用实际操作的本地化对象，他一般是由ActivityManagerNative的asInterface方法获取到的。在这个方法中会实现IActivityManager接口的所有方法，而在具体的方法中会使用远端服务的Binder对象方法transact发送命令给远端中间者。

3、ActivityManagerNative：这个是远端中间者对象，也就是我们之前分析的Stub类，只是不知道为何AMS中不叫这个名称了，
所以以后分析系统服务源码的时候，看到如果继承Binder类同时实现了IXXX接口，那么这个类就是远端服务的中间者，
他主要有两个功能，一个是可以将远端服务的Binder对象转化成本地实际对象，还有一个就是可以接受本地端中间者也就是Proxy对象发送的命令，
在onTransact方法中做处理，而在这个方法中其实会回调IActivityManager接口中指定的方法，而具体的接口方法实现则是在ActivityManagerService中

4、ActivityManagerService：这个是远端服务中具体方法实现的类，在这里就是真正的逻辑处理了，而这个类是运行在系统服务进程中的，也就是system_server中。

从上面的流程可以看到，Android中的服务大部分都符合这个规则：

IXXX是AIDL接口类型定义逻辑方法

XXXProxy是本地端代理对象，也是给应用操作的实际对象

XXXNative/XXX$Stub是远端服务的中间者对象，主要用来处理应用发送过来的命令处理工作

XXXService是最终的服务逻辑实现方法的地方，运行在远端进程中